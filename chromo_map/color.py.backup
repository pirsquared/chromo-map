"""Color module for chromo_map package."""

import re
import uuid
import colorsys
from typing import Tuple, Union, Optional, Any, Sequence, List, Dict, TYPE_CHECKING
from textwrap import dedent
import json
import base64
from importlib_resources import files
from IPython.display import HTML
from jinja2 import Template
import numpy as np
from _plotly_utils import colors as plotly_colors
from matplotlib.colors import LinearSegmentedColormap as LSC
from matplotlib.colors import ListedColormap as LC
from matplotlib.colors import to_rgba, to_rgb
import matplotlib.pyplot as plt
import svgwrite
import palettable
from palettable.palette import Palette
from pirrtools import AttrDict, find_instances
from pirrtools.sequences import lcm
from bs4 import BeautifulSoup

if TYPE_CHECKING:
    from chromo_map.core.gradient import Gradient


def _rgb_c(c: str) -> str:
    return rf"(?P<{c}>[^,\s]+)"


_COMMA = r"\s*,\s*"
_red = _rgb_c("red")
_grn = _rgb_c("grn")
_blu = _rgb_c("blu")
_alp = _rgb_c("alp")
_rgb_pat = _COMMA.join([_red, _grn, _blu]) + f"({_COMMA}{_alp})?"
_RGB_PATTERN = re.compile(rf"rgba?\({_rgb_pat}\)")

_VALID_MPL_COLORS = plt.colormaps()


def rgba_to_tup(rgbstr: str) -> Optional[Tuple[float, float, float, float]]:
    """Convert an RGBA string to a tuple."""
    match = _RGB_PATTERN.match(rgbstr)
    if match:
        gdict = match.groupdict()
        red = int(gdict["red"])
        grn = int(gdict["grn"])
        blu = int(gdict["blu"])
        if (alp := gdict["alp"]) is not None:
            alp = float(alp)
            if not 0 <= alp <= 1:
                raise ValueError("Alpha must be between 0 and 1.")
        else:
            alp = 1
        rgb_vals = to_rgb(f"#{red:02x}{grn:02x}{blu:02x}")
        return (rgb_vals[0], rgb_vals[1], rgb_vals[2], alp)
    return None


def hexstr_to_tup(hexstr: str) -> Optional[Tuple[float, float, float, float]]:
    """Convert a hex string to a tuple."""
    try:
        rgba_vals = to_rgba(hexstr)
        return (rgba_vals[0], rgba_vals[1], rgba_vals[2], rgba_vals[3])
    except ValueError:
        return None


def _is_valid_color_values(vals: List[float]) -> bool:
    """Check if values are valid color values (0-1 range)."""
    return all(0 <= x <= 1 for x in vals)


def clr_to_tup(clr: Any) -> Any:
    """Convert a color to a tuple."""
    if isinstance(clr, str):
        return hexstr_to_tup(clr) or rgba_to_tup(clr)
    
    if isinstance(clr, (tuple, list)):
        clr_list = list(clr)
        
        # Handle 3 or 4 element sequences
        if len(clr_list) in (3, 4):
            try:
                numeric_vals = [float(x) for x in clr_list]
                if _is_valid_color_values(numeric_vals):
                    # Add alpha if missing
                    if len(numeric_vals) == 3:
                        numeric_vals.append(1.0)
                    return tuple(numeric_vals)
            except (ValueError, TypeError):
                pass
        
        # Return original format if not valid color values
        return tuple(clr_list) if isinstance(clr, tuple) else clr_list
    
    # Try matplotlib's to_rgba as fallback
    try:
        rgba_vals = to_rgba(clr)
        return (rgba_vals[0], rgba_vals[1], rgba_vals[2], rgba_vals[3])
    except (ValueError, TypeError):
        return None


class Color:
    """A class for representing colors.

    You can pass in a color as a tuple of RGB or
    RGBA values in which the values are between 0 and 1, a hex string with or without an
    alpha value, or an RGB or RGBA string in the form `'rgb(r, g, b)'` or
    `'rgba(r, g, b, a)'`.  The alpha value is optional in all cases.

    You can also pass in another Color object to create a copy of it with an optional
    new alpha value.

    The class has properties that return the color in various formats including tuples,
    hex strings, RGB strings, and RGBA strings.

    You can also interpolate between two colors by passing in another color and a factor
    between 0 and 1.


    Examples
    --------

    Simple red color:

    .. testcode::

        from chromo_map import Color
        Color('red')

    .. html-output::

        from chromo_map import Color
        print(Color('red')._repr_html_())

    Simple red color with alpha:

    .. testcode::

        from chromo_map import Color
        Color('red', 0.5)

    .. html-output::

            from chromo_map import Color
            print(Color('red', 0.5)._repr_html_())

    Green with hex string:

    .. testcode::

        from chromo_map import Color
        Color('#007f00')

    .. html-output::

        from chromo_map import Color
        print(Color('#007f00')._repr_html_())

    Blue with RGB string:

    .. testcode::

        from chromo_map import Color
        Color('rgb(0, 0, 255)')

    .. html-output::

        from chromo_map import Color
        print(Color('rgb(0, 0, 255)')._repr_html_())

    Blue with RGBA string and overidden alpha:

    .. testcode::

        from chromo_map import Color
        Color('rgba(0, 0, 255, 0.5)', 0.75)

    .. html-output::

        from chromo_map import Color
        print(Color('rgba(0, 0, 255, 0.5)', 0.75)._repr_html_())


    """

    def __init__(
        self, 
        clr: Union['Color', str, Tuple[float, ...], Sequence[float], np.ndarray], 
        alpha: Optional[float] = None
    ) -> None:
        # Initialize RGBA attributes
        self.r: float
        self.g: float  
        self.b: float
        self.a: float
        
        if isinstance(clr, Color):
            self.__dict__.update(clr.__dict__)
            if alpha is not None:
                self.a = alpha
        else:
            if isinstance(clr, (tuple, list, np.ndarray)):
                # Extract RGB and optional alpha from sequence
                clr_list = list(clr)
                if len(clr_list) < 3:
                    raise ValueError("Color sequence must have at least 3 values (RGB)")
                
                red, grn, blu = float(clr_list[0]), float(clr_list[1]), float(clr_list[2])
                if alpha is not None:
                    alp = alpha
                elif len(clr_list) > 3:
                    alp = float(clr_list[3])
                else:
                    alp = 1.0

            elif isinstance(clr, str):
                tup = clr_to_tup(clr)
                if tup is None:
                    raise ValueError("Invalid color input.")
                red, grn, blu, alp = tup
                alp = alpha if alpha is not None else alp

            else:
                raise ValueError(f"Invalid color input '{type(clr).__name__}'.")

            if all(0 <= x <= 1 for x in (red, grn, blu, alp)):
                self.r = red
                self.g = grn
                self.b = blu
                self.a = alp
            else:
                raise ValueError("Color values must be between 0 and 1.")

    @property
    def tup(self):
        """Return the color as a tuple.

        Returns
        -------
        Tuple[float, float, float, float]
            The color as a tuple of RGBA values between 0 and 1.

        Examples
        --------

        Get the color as a tuple:

        .. testcode::

            from chromo_map import Color
            orange = Color('orange', 0.5)
            orange.tup

        .. testoutput::

            (1.0, 0.6470588235294118, 0.0, 0.5)

        """
        return self.r, self.g, self.b, self.a

    @property
    def hexatup(self):
        """Return the color as a tuple of hex values.

        Returns
        -------
        Tuple[int, int, int, int]
            The color as a tuple of RGBA values between 0 and 255.

        Examples
        --------

        Get the color as a tuple of hex values:

        .. testcode::

            from chromo_map import Color
            orange = Color('orange', 0.5)
            orange.hexatup

        .. testoutput::

            (255, 165, 0, 127)

        """
        return tuple(int(x * 255) for x in self.tup)

    @property
    def hextup(self):
        """Return the color as a tuple of hex values.

        Returns
        -------
        Tuple[int, int, int]
            The color as a tuple of RGB values between 0 and 255.

        Examples
        --------

        Get the color as a tuple of hex values:

        .. testcode::

            from chromo_map import Color
            orange = Color('orange', 0.5)
            orange.hextup

        .. testoutput::

            (255, 165, 0)

        """
        return self.hexatup[:3]

    @property
    def rgbtup(self):
        """Return the color as a tuple of RGB values.

        Returns
        -------
        Tuple[int, int, int]
            The color as a tuple of RGB values between 0 and 255.

        Examples
        --------

        Get the color as a tuple of hex values:

        .. testcode::

            from chromo_map import Color
            orange = Color('orange', 0.5)
            orange.rgbtup

        .. testoutput::

            (255, 165, 0)

        """
        return self.hextup

    @property
    def rgbatup(self):
        """Return the color as a tuple of RGBA values.

        Returns
        -------
        Tuple[int, int, int, float]
            The color as a tuple of RGB values between 0 and 255 and an alpha value
            between 0 and 1.

        Examples
        --------
        Get the color as a tuple of RGBA values:

        .. testcode::

            from chromo_map import Color
            orange = Color('orange', 0.5)
            orange.rgbatup

        .. testoutput::

            (255, 165, 0, 0.5)

        """
        return self.rgbtup + (self.a,)

    @property
    def hex(self):
        """Return the color as a hex string.

        Returns
        -------
        str
            The color as a hex string.

        Examples
        --------

        Get the color as a hex string:

        .. testcode::

            from chromo_map import Color
            orange = Color('orange', 0.5)
            orange.hex

        .. testoutput::

            '#ffa500'

        """
        r, g, b = self.hextup
        return f"#{r:02x}{g:02x}{b:02x}"

    @property
    def hexa(self):
        """Return the color as a hex string with an alpha value.

        Returns
        -------
        str
            The color as a hex string with an alpha value.

        Examples
        --------

        Get the color as a hex string with an alpha value:

        .. testcode::

            from chromo_map import Color
            orange = Color('orange', 0.5)
            orange.hexa

        .. testoutput::

                '#ffa50080'

        """
        r, g, b, a = self.hexatup
        return f"#{r:02x}{g:02x}{b:02x}{a:02x}"

    @property
    def rgb(self):
        """Return the color as an RGB string.

        Returns
        -------
        str
            The color as an RGB string.

        Examples
        --------

        Get the color as an RGB string:

        .. testcode::

            from chromo_map import Color
            orange = Color('orange', 0.5)
            orange.rgb

        .. testoutput::

            'rgb(255, 165, 0)'

        """
        r, g, b = self.rgbtup
        return f"rgb({r}, {g}, {b})"

    @property
    def rgba(self):
        """Return the color as an RGBA string.

        Returns
        -------
        str
            The color as an RGBA string.

        Examples
        --------

        Get the color as an RGBA string:

        .. testcode::

            from chromo_map import Color
            orange = Color('orange', 0.5)
            orange.rgba

        .. testoutput::

            'rgba(255, 165, 0, 0.5)'

        """
        r, g, b, a = self.rgbatup
        return f"rgba({r}, {g}, {b}, {a:.1f})"

    def interpolate(self, other: 'Color', factor: float) -> 'Color':
        """Interpolate between two colors.

        Parameters
        ----------
        other : Color
            The other color to interpolate with.

        factor : float
            The interpolation factor between 0 and 1.

        Returns
        -------
        Color
            The interpolated color.

        Examples
        --------
        Interpolate between red and blue:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            blue = Color('blue')

            red.interpolate(blue, 0.5)

        .. html-output::

            from chromo_map import Color
            red = Color('red')
            blue = Color('blue')
            print(red.interpolate(blue, 0.5)._repr_html_())

        """
        r = self.r + (other.r - self.r) * factor
        g = self.g + (other.g - self.g) * factor
        b = self.b + (other.b - self.b) * factor
        a = self.a + (other.a - self.a) * factor
        return Color((r, g, b, a))

    def __or__(self, other: 'Color') -> 'Color':
        """Interpolate between two colors assuming a factor of 0.5.

        Parameters
        ----------
        other : Color
            The other color to interpolate with.

        Returns
        -------
        Color
            The interpolated color.

        Examples
        --------

        Interpolate between red and blue:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            blue = Color('blue')
            red | blue

        .. html-output::

            from chromo_map import Color
            red = Color('red')
            blue = Color('blue')
            print((red | blue)._repr_html_())

        """
        return self.interpolate(other, 0.5)

    def _repr_html_(self) -> str:
        random_id = uuid.uuid4().hex
        style = dedent(
            f"""\
        <style>
            #_{random_id} {{ 
                position: relative;
                display: inline-block;
                cursor: pointer;
                background: {self.rgba};
                width: 2rem; height: 1.5rem;
            }}
            #_{random_id}::after {{
                content: attr(data-tooltip);
                position: absolute;
                bottom: 50%;
                left: 0%;
                transform: translateY(50%);
                padding: 0.125rem;
                white-space: pre;
                font-size: 0.75rem;
                font-family: monospace;
                background: rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(0.25rem);
                color: white;
                border-radius: 0.25rem;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.1s ease-in-out;
                z-index: -1;
            }}
            #_{random_id}:hover::after {{
                opacity: 1;
                z-index: 1;
            }}
        </style>       
        """
        )
        tooltip = dedent(
            f"""\
        RGBA: {self.rgba[5:-1]}
        HEXA: {self.hexa}\
        """
        )
        return dedent(
            f"""\
            <div>
                {style}
                <div id="_{random_id}" class="color" data-tooltip="{tooltip}"></div>
            </div>
        """
        )

    @property
    def hsv(self):
        """Return the color as HSV values.

        Returns
        -------
        Tuple[float, float, float]
            The color as a tuple of HSV values (hue: 0-360, saturation: 0-1, value: 0-1).

        Examples
        --------

        Get the color as HSV values:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            red.hsv

        .. testoutput::

            (0.0, 1.0, 1.0)

        """
        h, s, v = colorsys.rgb_to_hsv(self.r, self.g, self.b)
        return (h * 360, s, v)

    @property
    def hsl(self):
        """Return the color as HSL values.

        Returns
        -------
        Tuple[float, float, float]
            The color as a tuple of HSL values (hue: 0-360, saturation: 0-1, lightness: 0-1).

        Examples
        --------

        Get the color as HSL values:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            red.hsl

        .. testoutput::

            (0.0, 1.0, 0.5)

        """
        h, l, s = colorsys.rgb_to_hls(self.r, self.g, self.b)
        return (h * 360, s, l)

    @property
    def luminance(self):
        """Return the relative luminance of the color.

        Uses the WCAG 2.1 formula for relative luminance.

        Returns
        -------
        float
            The relative luminance value (0-1).

        Examples
        --------

        Get the luminance of a color:

        .. testcode::

            from chromo_map import Color
            white = Color('white')
            black = Color('black')
            print(f"White luminance: {white.luminance:.3f}")
            print(f"Black luminance: {black.luminance:.3f}")

        .. testoutput::

            White luminance: 1.000
            Black luminance: 0.000

        """
        def _linearize(c):
            """Convert sRGB color component to linear RGB."""
            if c <= 0.03928:
                return c / 12.92
            return ((c + 0.055) / 1.055) ** 2.4
        
        r_lin = _linearize(self.r)
        g_lin = _linearize(self.g)
        b_lin = _linearize(self.b)
        
        return 0.2126 * r_lin + 0.7152 * g_lin + 0.0722 * b_lin

    def adjust_hue(self, degrees: float) -> 'Color':
        """Adjust the hue of the color by the specified degrees.

        Parameters
        ----------
        degrees : float
            The number of degrees to adjust the hue by.

        Returns
        -------
        Color
            A new color with the adjusted hue.

        Examples
        --------

        Adjust hue by 120 degrees:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            green = red.adjust_hue(120)
            green

        .. html-output::

            from chromo_map import Color
            red = Color('red')
            green = red.adjust_hue(120)
            print(green._repr_html_())

        """
        h, s, v = self.hsv
        new_h = (h + degrees) % 360
        r, g, b = colorsys.hsv_to_rgb(new_h / 360, s, v)
        return Color((r, g, b, self.a))

    def adjust_saturation(self, factor: float) -> 'Color':
        """Adjust the saturation of the color by the specified factor.

        Parameters
        ----------
        factor : float
            The factor to multiply the saturation by. Values > 1 increase saturation,
            values < 1 decrease saturation.

        Returns
        -------
        Color
            A new color with the adjusted saturation.

        Examples
        --------

        Increase saturation by 50%:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            saturated = red.adjust_saturation(1.5)
            saturated

        .. html-output::

            from chromo_map import Color
            red = Color('red')
            saturated = red.adjust_saturation(1.5)
            print(saturated._repr_html_())

        """
        h, s, v = self.hsv
        new_s = min(1.0, max(0.0, s * factor))
        r, g, b = colorsys.hsv_to_rgb(h / 360, new_s, v)
        return Color((r, g, b, self.a))

    def adjust_brightness(self, factor: float) -> 'Color':
        """Adjust the brightness (value) of the color by the specified factor.

        Parameters
        ----------
        factor : float
            The factor to multiply the brightness by. Values > 1 increase brightness,
            values < 1 decrease brightness.

        Returns
        -------
        Color
            A new color with the adjusted brightness.

        Examples
        --------

        Increase brightness by 20%:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            bright = red.adjust_brightness(1.2)
            bright

        .. html-output::

            from chromo_map import Color
            red = Color('red')
            bright = red.adjust_brightness(1.2)
            print(bright._repr_html_())

        """
        h, s, v = self.hsv
        new_v = min(1.0, max(0.0, v * factor))
        r, g, b = colorsys.hsv_to_rgb(h / 360, s, new_v)
        return Color((r, g, b, self.a))

    def adjust_lightness(self, factor: float) -> 'Color':
        """Adjust the lightness (HSL) of the color by the specified factor.

        Parameters
        ----------
        factor : float
            The factor to multiply the lightness by. Values > 1 increase lightness,
            values < 1 decrease lightness.

        Returns
        -------
        Color
            A new color with the adjusted lightness.

        Examples
        --------

        Decrease lightness by 20%:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            dark = red.adjust_lightness(0.8)
            dark

        .. html-output::

            from chromo_map import Color
            red = Color('red')
            dark = red.adjust_lightness(0.8)
            print(dark._repr_html_())

        """
        h, s, l = self.hsl
        new_l = min(1.0, max(0.0, l * factor))
        r, g, b = colorsys.hls_to_rgb(h / 360, new_l, s)
        return Color((r, g, b, self.a))

    def set_hsv(self, h: Optional[float] = None, s: Optional[float] = None, v: Optional[float] = None) -> 'Color':
        """Set specific HSV values while keeping others unchanged.

        Parameters
        ----------
        h : float, optional
            The hue value (0-360). If None, keeps current hue.
        s : float, optional
            The saturation value (0-1). If None, keeps current saturation.
        v : float, optional
            The value/brightness (0-1). If None, keeps current value.

        Returns
        -------
        Color
            A new color with the specified HSV values.

        Examples
        --------

        Set hue to 240 (blue):

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            blue = red.set_hsv(h=240)
            blue

        .. html-output::

            from chromo_map import Color
            red = Color('red')
            blue = red.set_hsv(h=240)
            print(blue._repr_html_())

        """
        current_h, current_s, current_v = self.hsv
        new_h = h if h is not None else current_h
        new_s = s if s is not None else current_s
        new_v = v if v is not None else current_v
        
        r, g, b = colorsys.hsv_to_rgb(new_h / 360, new_s, new_v)
        return Color((r, g, b, self.a))

    def contrast_ratio(self, other: 'Color') -> float:
        """Calculate the contrast ratio between this color and another.

        Uses the WCAG 2.1 formula for contrast ratio.

        Parameters
        ----------
        other : Color
            The other color to compare against.

        Returns
        -------
        float
            The contrast ratio (1:1 to 21:1).

        Examples
        --------

        Calculate contrast ratio between black and white:

        .. testcode::

            from chromo_map import Color
            black = Color('black')
            white = Color('white')
            black.contrast_ratio(white)

        .. testoutput::

            21.0

        """
        l1 = self.luminance
        l2 = other.luminance
        
        # Ensure l1 is the lighter color
        if l1 < l2:
            l1, l2 = l2, l1
        
        return (l1 + 0.05) / (l2 + 0.05)

    def is_accessible(self, other: 'Color', level: str = 'AA') -> bool:
        """Check if this color has sufficient contrast with another for accessibility.

        Parameters
        ----------
        other : Color
            The other color to compare against.
        level : str, default 'AA'
            The WCAG level to check against ('AA' or 'AAA').

        Returns
        -------
        bool
            True if the contrast ratio meets the specified level.

        Examples
        --------

        Check if black text on white background is accessible:

        .. testcode::

            from chromo_map import Color
            black = Color('black')
            white = Color('white')
            black.is_accessible(white)

        .. testoutput::

            True

        """
        ratio = self.contrast_ratio(other)
        if level == 'AAA':
            return ratio >= 7.0
        else:  # AA level
            return ratio >= 4.5

    def complementary(self) -> 'Color':
        """Get the complementary color (opposite on the color wheel).

        Returns
        -------
        Color
            The complementary color.

        Examples
        --------

        Get the complement of red:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            cyan = red.complementary()
            cyan

        .. html-output::

            from chromo_map import Color
            red = Color('red')
            cyan = red.complementary()
            print(cyan._repr_html_())

        """
        return self.adjust_hue(180)

    def triadic(self) -> Tuple['Color', 'Color']:
        """Get the triadic colors (120 degrees apart on the color wheel).

        Returns
        -------
        Tuple[Color, Color]
            A tuple of two triadic colors.

        Examples
        --------

        Get the triadic colors of red:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            triad1, triad2 = red.triadic()
            print(f"Triad 1: {triad1.hex}")
            print(f"Triad 2: {triad2.hex}")

        .. testoutput::

            Triad 1: #00ff00
            Triad 2: #0000ff

        """
        return (self.adjust_hue(120), self.adjust_hue(240))

    def analogous(self, angle: float = 30) -> Tuple['Color', 'Color']:
        """Get analogous colors (adjacent on the color wheel).

        Parameters
        ----------
        angle : float, default 30
            The angle in degrees for the analogous colors.

        Returns
        -------
        Tuple[Color, Color]
            A tuple of two analogous colors.

        Examples
        --------

        Get analogous colors of red:

        .. testcode::

            from chromo_map import Color
            red = Color('red')
            analog1, analog2 = red.analogous()
            print(f"Analogous 1: {analog1.hex}")
            print(f"Analogous 2: {analog2.hex}")

        .. testoutput::

            Analogous 1: #ff8000
            Analogous 2: #ff0080

        """
        return (self.adjust_hue(angle), self.adjust_hue(-angle))

    def find_accessible_version(self, target_color: Union['Color', str], level: str = 'AA', 
                              adjust_lightness: bool = True) -> 'Color':
        """Find an accessible version of this color against a target.

        Parameters
        ----------
        target_color : Color or str
            The color to ensure accessibility against.
        level : str, default 'AA'
            The WCAG level to achieve ('AA' or 'AAA').
        adjust_lightness : bool, default True
            Whether to adjust lightness (True) or brightness/value (False).

        Returns
        -------
        Color
            An accessible version of this color.

        Examples
        --------

        Find accessible version of gray against white:

        .. testcode::

            from chromo_map import Color
            gray = Color('#888888')
            accessible = gray.find_accessible_version('white')
            print(f"Accessible: {accessible.hex}")

        .. testoutput::

            Accessible: #595959

        """
        from chromo_map.color import find_accessible_color
        return find_accessible_color(self, target_color, level, adjust_lightness)

    def maximize_contrast_iterative(self, target_color: Union['Color', str], level: str = 'AA', 
                                  adjust_lightness: bool = True, step_size: float = 0.1, 
                                  max_attempts: int = 50) -> 'Color':
        """Maximize contrast against target using iterative approach.

        Parameters
        ----------
        target_color : Color or str
            The color to maximize contrast against.
        level : str, default 'AA'
            The WCAG level to achieve ('AA' or 'AAA').
        adjust_lightness : bool, default True
            Whether to adjust lightness (True) or brightness/value (False).
        step_size : float, default 0.1
            The step size for adjustments.
        max_attempts : int, default 50
            Maximum number of adjustment attempts.

        Returns
        -------
        Color
            The color with maximized contrast.

        Examples
        --------

        Maximize contrast iteratively:

        .. testcode::

            from chromo_map import Color
            gray = Color('#888888')
            optimized = gray.maximize_contrast_iterative('white')
            print(f"Optimized: {optimized.hex}")

        .. testoutput::

            Optimized: #000000

        """
        from chromo_map.color import find_maximal_contrast_iterative
        return find_maximal_contrast_iterative(self, target_color, level, adjust_lightness, step_size, max_attempts)

    def maximize_contrast_binary_search(self, target_color: Union['Color', str], level: str = 'AA', 
                                       adjust_lightness: bool = True, precision: float = 0.001) -> 'Color':
        """Maximize contrast against target using binary search.

        Parameters
        ----------
        target_color : Color or str
            The color to maximize contrast against.
        level : str, default 'AA'
            The WCAG level to achieve ('AA' or 'AAA').
        adjust_lightness : bool, default True
            Whether to adjust lightness (True) or brightness/value (False).
        precision : float, default 0.001
            The precision for binary search convergence.

        Returns
        -------
        Color
            The color with maximized contrast.

        Examples
        --------

        Maximize contrast with binary search:

        .. testcode::

            from chromo_map import Color
            gray = Color('#888888')
            optimized = gray.maximize_contrast_binary_search('white')
            print(f"Optimized: {optimized.hex}")

        .. testoutput::

            Optimized: #0d0d0d

        """
        from chromo_map.color import find_maximal_contrast_binary_search
        return find_maximal_contrast_binary_search(self, target_color, level, adjust_lightness, precision)

    def maximize_contrast_optimization(self, target_color: Union['Color', str], level: str = 'AA', 
                                     method: str = 'golden_section') -> 'Color':
        """Maximize contrast against target using mathematical optimization.

        Parameters
        ----------
        target_color : Color or str
            The color to maximize contrast against.
        level : str, default 'AA'
            The WCAG level to achieve ('AA' or 'AAA').
        method : str, default 'golden_section'
            The optimization method to use ('golden_section' or 'gradient_descent').

        Returns
        -------
        Color
            The color with maximized contrast.

        Examples
        --------

        Maximize contrast with optimization:

        .. testcode::

            from chromo_map import Color
            gray = Color('#888888')
            optimized = gray.maximize_contrast_optimization('white')
            print(f"Optimized: {optimized.hex}")

        .. testoutput::

            Optimized: #0d0d0d

        """
        from chromo_map.color import find_maximal_contrast_optimization
        return find_maximal_contrast_optimization(self, target_color, level, method)

    def __eq__(self, other: object) -> bool:
        """Check if two colors are equal.

        Only checks the result of the tuple property.

        Parameters
        ----------
        other : Color
            The other color to compare to.

        Returns
        -------
        bool
            Whether the colors are equal.
        """
        if not isinstance(other, Color):
            return False
        return bool(np.isclose(self.tup, other.tup).all())


# Accessibility functions
def find_accessible_color(color: Color, background: Color, level: str = 'AA') -> Color:
    """Find an accessible version of a color against a background."""
    target_ratio = 7.0 if level == 'AAA' else 4.5
    
    # If already accessible, return as-is
    if color.contrast_ratio(background) >= target_ratio:
        return color
        
    # Try adjusting lightness
    best_color = color
    best_contrast = color.contrast_ratio(background)
    
    # Try making it darker
    for factor in [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]:
        dark_color = color.adjust_lightness(factor)
        contrast = dark_color.contrast_ratio(background)
        if contrast >= target_ratio and contrast > best_contrast:
            best_color = dark_color
            best_contrast = contrast
            
    # Try making it lighter
    for factor in [1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]:
        light_color = color.adjust_lightness(factor)
        contrast = light_color.contrast_ratio(background)
        if contrast >= target_ratio and contrast > best_contrast:
            best_color = light_color
            best_contrast = contrast
            
    return best_color


def find_maximal_contrast_iterative(color: Color, background: Color, level: str = 'AA',
                                   adjust_lightness: bool = True, step_size: float = 0.1,
                                   max_attempts: int = 50) -> Color:
    """Find maximal contrast using iterative approach."""
    target_ratio = 7.0 if level == 'AAA' else 4.5
    
    best_color = color
    best_contrast = color.contrast_ratio(background)
    
    for _ in range(max_attempts):
        if adjust_lightness:
            # Try darker
            darker = best_color.adjust_lightness(1.0 - step_size)
            darker_contrast = darker.contrast_ratio(background)
            if darker_contrast > best_contrast:
                best_color = darker
                best_contrast = darker_contrast
                continue
                
            # Try lighter
            lighter = best_color.adjust_lightness(1.0 + step_size)
            lighter_contrast = lighter.contrast_ratio(background)
            if lighter_contrast > best_contrast:
                best_color = lighter
                best_contrast = lighter_contrast
                continue
        else:
            # Try dimmer
            dimmer = best_color.adjust_brightness(1.0 - step_size)
            dimmer_contrast = dimmer.contrast_ratio(background)
            if dimmer_contrast > best_contrast:
                best_color = dimmer
                best_contrast = dimmer_contrast
                continue
                
            # Try brighter
            brighter = best_color.adjust_brightness(1.0 + step_size)
            brighter_contrast = brighter.contrast_ratio(background)
            if brighter_contrast > best_contrast:
                best_color = brighter
                best_contrast = brighter_contrast
                continue
                
        # No improvement, reduce step size
        step_size *= 0.8
        if step_size < 0.001:
            break
            
    return best_color


def find_maximal_contrast_binary_search(color: Color, background: Color, level: str = 'AA',
                                       adjust_lightness: bool = True, precision: float = 0.001) -> Color:
    """Find maximal contrast using binary search."""
    target_ratio = 7.0 if level == 'AAA' else 4.5
    
    best_color = color
    best_contrast = color.contrast_ratio(background)
    
    # Binary search on lightness/brightness
    low, high = 0.0, 2.0
    
    while high - low > precision:
        mid = (low + high) / 2
        
        if adjust_lightness:
            test_color = color.adjust_lightness(mid)
        else:
            test_color = color.adjust_brightness(mid)
            
        contrast = test_color.contrast_ratio(background)
        
        if contrast > best_contrast:
            best_color = test_color
            best_contrast = contrast
            
        if contrast >= target_ratio:
            low = mid
        else:
            high = mid
            
    return best_color


def find_maximal_contrast_optimization(color: Color, background: Color, level: str = 'AA',
                                     method: str = 'golden_section') -> Color:
    """Find maximal contrast using mathematical optimization."""
    target_ratio = 7.0 if level == 'AAA' else 4.5
    
    if method == 'golden_section':
        # Golden section search
        phi = (1 + 5**0.5) / 2
        resphi = 2 - phi
        
        # Search range for lightness adjustment
        a, b = 0.1, 2.0
        tol = 1e-5
        
        # Initial points
        x1 = a + resphi * (b - a)
        x2 = a + (1 - resphi) * (b - a)
        
        f1 = -color.adjust_lightness(x1).contrast_ratio(background)
        f2 = -color.adjust_lightness(x2).contrast_ratio(background)
        
        while abs(b - a) > tol:
            if f1 < f2:
                a = x1
                x1 = x2
                f1 = f2
                x2 = a + (1 - resphi) * (b - a)
                f2 = -color.adjust_lightness(x2).contrast_ratio(background)
            else:
                b = x2
                x2 = x1
                f2 = f1
                x1 = a + resphi * (b - a)
                f1 = -color.adjust_lightness(x1).contrast_ratio(background)
                
        optimal_factor = (a + b) / 2
        return color.adjust_lightness(optimal_factor)
    
    else:
        # Fallback to iterative method
        return find_maximal_contrast_iterative(color, background, level)


class Swatch:
    """A class for representing a collection of gradients."""

    def __init__(self, gradients, maxn=32):
        self.maxn = maxn
        self.gradients = []
        if isinstance(gradients, dict):
            for name, colors in gradients.items():
                try:
                    from chromo_map.core.gradient import Gradient
                    self.gradients.append(Gradient(colors, name=name))
                except ValueError as e:
                    raise e
        elif isinstance(gradients, (list, tuple)):
            self.gradients = list(gradients)
        else:
            raise ValueError("Gradients must be a dict or list of Gradient objects")

    def to_dict(self):
        """Convert to a dictionary of gradient names to colors."""
        return {gradient.name: gradient.colors for gradient in self.gradients}

    def __iter__(self):
        """Iterate over gradients."""
        return iter(self.gradients)

    def __len__(self):
        """Return the number of gradients."""
        return len(self.gradients)

    def with_max(self, maxn):
        """Return a new Swatch with a different maximum number of gradients."""
        return Swatch(self.gradients, maxn=maxn)

    def to_grid(self, as_png=False):
        """Convert the swatch to an HTML grid."""
        n = len(self.gradients)
        if n == 0:
            return ""
        template = Template(
            dedent(
                """\
            <div id="_{{ random_id }}" class="color-swatch">
                <style>
                    #_{{ random_id }} {
                        display: grid;
                        grid-template-columns: repeat(auto-fill, minmax(10rem, 1fr));
                        gap: 0.5rem 1rem;
                        justify-content: space-between;
                        overflow: hidden;
                        resize: both;
                        width: min(65rem, 100%);
                    }
                    #_{{ random_id }} div {
                        width: 100%;
                    }
                    #_{{ random_id }} > div.gradient {
                        width: 100%;
                        height: min(4rem, 100%);
                        display: grid;
                        gap: 0.2rem;
                        grid-template-rows: 1rem auto;
                    }
                    #_{{ random_id }} .color {
                        height: minmax(1.5rem, 100%);
                    }
                    #_{{ random_id }} > div.gradient > strong {
                        margin: 0;
                        padding: 0;
                    }
                    #_{{ random_id }} img {height: 100%;}
                </style>
                {% for gradient in gradients %}
                    {{ gradient.to_div(maxn, as_png=as_png).data }}
                {% endfor %}
            </div>
        """
            )
        )
        random_id = uuid.uuid4().hex
        return HTML(
            template.render(
                gradients=self.gradients, random_id=random_id, maxn=self.maxn, as_png=as_png
            )
        )
    
    def append(self, gradient: 'Gradient'):
        """Append a new gradient to the swatch.

        Parameters
        ----------
        gradient : Gradient
            The gradient to append.

        Returns
        -------
        None

        Examples
        --------

        Append a new gradient to the swatch:

        .. testcode::

            from chromo_map import Swatch, Gradient
            swatch = Swatch([])
            swatch.append(Gradient(['#ff0000', '#00ff00', '#0000ff'], name='RGB'))

        .. html-output::

            from chromo_map import Swatch, Gradient
            swatch = Swatch([])
            swatch.append(Gradient(['#ff0000', '#00ff00', '#0000ff'], name='RGB'))
            print(swatch.to_grid().data)

        """
        self.gradients.append(gradient)

    def adjust_hue(self, degrees: float) -> 'Swatch':
        """Adjust the hue of all gradients in the swatch.

        Parameters
        ----------
        degrees : float
            The number of degrees to adjust the hue by.

        Returns
        -------
        Swatch
            A new swatch with adjusted hue.

        Examples
        --------

        Adjust hue by 90 degrees:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff0000', '#00ff00'], name='RedGreen')]
            swatch = Swatch(gradients)
            shifted = swatch.adjust_hue(90)
            shifted

        .. html-output::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff0000', '#00ff00'], name='RedGreen')]
            swatch = Swatch(gradients)
            shifted = swatch.adjust_hue(90)
            print(shifted._repr_html_())

        """
        new_gradients = [gradient.adjust_hue(degrees) for gradient in self.gradients]
        return Swatch(new_gradients, maxn=self.maxn)

    def adjust_saturation(self, factor: float) -> 'Swatch':
        """Adjust the saturation of all gradients in the swatch.

        Parameters
        ----------
        factor : float
            The factor to multiply saturation by.

        Returns
        -------
        Swatch
            A new swatch with adjusted saturation.

        Examples
        --------

        Decrease saturation by 25%:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff0000', '#00ff00'], name='RedGreen')]
            swatch = Swatch(gradients)
            desaturated = swatch.adjust_saturation(0.75)
            desaturated

        .. html-output::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff0000', '#00ff00'], name='RedGreen')]
            swatch = Swatch(gradients)
            desaturated = swatch.adjust_saturation(0.75)
            print(desaturated._repr_html_())

        """
        new_gradients = [gradient.adjust_saturation(factor) for gradient in self.gradients]
        return Swatch(new_gradients, maxn=self.maxn)

    def adjust_brightness(self, factor: float) -> 'Swatch':
        """Adjust the brightness of all gradients in the swatch.

        Parameters
        ----------
        factor : float
            The factor to multiply brightness by.

        Returns
        -------
        Swatch
            A new swatch with adjusted brightness.

        Examples
        --------

        Increase brightness by 10%:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff0000', '#00ff00'], name='RedGreen')]
            swatch = Swatch(gradients)
            bright = swatch.adjust_brightness(1.1)
            bright

        .. html-output::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff0000', '#00ff00'], name='RedGreen')]
            swatch = Swatch(gradients)
            bright = swatch.adjust_brightness(1.1)
            print(bright._repr_html_())

        """
        new_gradients = [gradient.adjust_brightness(factor) for gradient in self.gradients]
        return Swatch(new_gradients, maxn=self.maxn)

    def adjust_lightness(self, factor: float) -> 'Swatch':
        """Adjust the lightness of all gradients in the swatch.

        Parameters
        ----------
        factor : float
            The factor to multiply lightness by.

        Returns
        -------
        Swatch
            A new swatch with adjusted lightness.

        Examples
        --------

        Decrease lightness by 15%:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff0000', '#00ff00'], name='RedGreen')]
            swatch = Swatch(gradients)
            dark = swatch.adjust_lightness(0.85)
            dark

        .. html-output::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff0000', '#00ff00'], name='RedGreen')]
            swatch = Swatch(gradients)
            dark = swatch.adjust_lightness(0.85)
            print(dark._repr_html_())

        """
        new_gradients = [gradient.adjust_lightness(factor) for gradient in self.gradients]
        return Swatch(new_gradients, maxn=self.maxn)

    def make_accessible(self, background_color: Union[Color, str], level: str = 'AA') -> 'Swatch':
        """Make all gradients in the swatch accessible against a background color.

        Parameters
        ----------
        background_color : Color or str
            The background color to ensure accessibility against.
        level : str, default 'AA'
            The WCAG level to achieve ('AA' or 'AAA').

        Returns
        -------
        Swatch
            A new swatch with accessible gradients.

        Examples
        --------

        Make swatch accessible against white background:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ffcccc', '#ccffcc'], name='Pastels')]
            swatch = Swatch(gradients)
            accessible = swatch.make_accessible('white')
            accessible

        .. html-output::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ffcccc', '#ccffcc'], name='Pastels')]
            swatch = Swatch(gradients)
            accessible = swatch.make_accessible('white')
            print(accessible._repr_html_())

        """
        new_gradients = [gradient.make_accessible(background_color, level) for gradient in self.gradients]
        return Swatch(new_gradients, maxn=self.maxn)

    def complementary(self) -> 'Swatch':
        """Get the complementary swatch (all gradients with complementary colors).

        Returns
        -------
        Swatch
            A new swatch with complementary gradients.

        Examples
        --------

        Get complementary swatch:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff0000', '#00ff00'], name='RedGreen')]
            swatch = Swatch(gradients)
            complement = swatch.complementary()
            complement

        .. html-output::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff0000', '#00ff00'], name='RedGreen')]
            swatch = Swatch(gradients)
            complement = swatch.complementary()
            print(complement._repr_html_())

        """
        new_gradients = [gradient.complementary() for gradient in self.gradients]
        return Swatch(new_gradients, maxn=self.maxn)

    def analyze_contrast(self, background_color: Union[Color, str]) -> Dict[str, Any]:
        """Analyze contrast ratios of all gradients against a background.

        Parameters
        ----------
        background_color : Color or str
            The background color to analyze against.

        Returns
        -------
        Dict[str, Any]
            Dictionary containing contrast analysis results for each gradient.

        Examples
        --------

        Analyze contrast against white background:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#000000', '#808080'], name='Darks')]
            swatch = Swatch(gradients)
            analysis = swatch.analyze_contrast('white')
            print(f"Gradients analyzed: {len(analysis['gradients'])}")

        .. testoutput::

            Gradients analyzed: 1

        """
        background = Color(background_color) if not isinstance(background_color, Color) else background_color
        gradient_analyses = []
        all_contrasts = []
        
        for gradient in self.gradients:
            analysis = gradient.analyze_contrast(background)
            gradient_analyses.append({
                'name': gradient.name,
                'analysis': analysis
            })
            all_contrasts.extend(analysis['contrasts'])
        
        # Overall statistics
        total_colors = len(all_contrasts)
        accessible_aa = sum(1 for c in all_contrasts if c >= 4.5)
        accessible_aaa = sum(1 for c in all_contrasts if c >= 7.0)
        
        return {
            'gradients': gradient_analyses,
            'total_colors': total_colors,
            'overall_average_contrast': sum(all_contrasts) / total_colors if all_contrasts else 0,
            'overall_min_contrast': min(all_contrasts) if all_contrasts else 0,
            'overall_max_contrast': max(all_contrasts) if all_contrasts else 0,
            'overall_accessible_aa_count': accessible_aa,
            'overall_accessible_aaa_count': accessible_aaa,
            'overall_accessibility_aa_score': accessible_aa / total_colors if total_colors else 0,
            'overall_accessibility_aaa_score': accessible_aaa / total_colors if total_colors else 0
        }

    def find_accessible_version(self, background_color: Union[Color, str], level: str = 'AA') -> 'Swatch':
        """Find accessible version of all gradients in the swatch.

        Parameters
        ----------
        background_color : Color or str
            The background color to ensure accessibility against.
        level : str, default 'AA'
            The WCAG level to achieve ('AA' or 'AAA').

        Returns
        -------
        Swatch
            A new swatch with accessible gradients.

        Examples
        --------

        Find accessible version of swatch:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ffcccc', '#ccffcc'], name='Light')]
            swatch = Swatch(gradients)
            accessible = swatch.find_accessible_version('white')
            accessible

        .. html-output::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ffcccc', '#ccffcc'], name='Light')]
            swatch = Swatch(gradients)
            accessible = swatch.find_accessible_version('white')
            print(accessible._repr_html_())

        """
        new_gradients = [gradient.find_accessible_version(background_color, level) for gradient in self.gradients]
        return Swatch(new_gradients, maxn=self.maxn)

    def maximize_contrast_iterative(self, background_color: Union[Color, str], level: str = 'AA',
                                   adjust_lightness: bool = True, step_size: float = 0.1,
                                   max_attempts: int = 50) -> 'Swatch':
        """Maximize contrast of all gradients using iterative approach.

        Parameters
        ----------
        background_color : Color or str
            The background color to maximize contrast against.
        level : str, default 'AA'
            The WCAG level to achieve ('AA' or 'AAA').
        adjust_lightness : bool, default True
            Whether to adjust lightness (True) or brightness/value (False).
        step_size : float, default 0.1
            The step size for adjustments.
        max_attempts : int, default 50
            Maximum number of adjustment attempts.

        Returns
        -------
        Swatch
            A new swatch with maximized contrast gradients.

        Examples
        --------

        Maximize contrast iteratively:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff6666', '#66ff66'], name='Light')]
            swatch = Swatch(gradients)
            optimized = swatch.maximize_contrast_iterative('white')
            optimized

        .. html-output::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff6666', '#66ff66'], name='Light')]
            swatch = Swatch(gradients)
            optimized = swatch.maximize_contrast_iterative('white')
            print(optimized._repr_html_())

        """
        new_gradients = [gradient.maximize_contrast_iterative(background_color, level, adjust_lightness, step_size, max_attempts) for gradient in self.gradients]
        return Swatch(new_gradients, maxn=self.maxn)

    def maximize_contrast_binary_search(self, background_color: Union[Color, str], level: str = 'AA',
                                       adjust_lightness: bool = True, precision: float = 0.001) -> 'Swatch':
        """Maximize contrast of all gradients using binary search.

        Parameters
        ----------
        background_color : Color or str
            The background color to maximize contrast against.
        level : str, default 'AA'
            The WCAG level to achieve ('AA' or 'AAA').
        adjust_lightness : bool, default True
            Whether to adjust lightness (True) or brightness/value (False).
        precision : float, default 0.001
            The precision for binary search convergence.

        Returns
        -------
        Swatch
            A new swatch with maximized contrast gradients.

        Examples
        --------

        Maximize contrast with binary search:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff6666', '#66ff66'], name='Light')]
            swatch = Swatch(gradients)
            optimized = swatch.maximize_contrast_binary_search('white')
            optimized

        .. html-output::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff6666', '#66ff66'], name='Light')]
            swatch = Swatch(gradients)
            optimized = swatch.maximize_contrast_binary_search('white')
            print(optimized._repr_html_())

        """
        new_gradients = [gradient.maximize_contrast_binary_search(background_color, level, adjust_lightness, precision) for gradient in self.gradients]
        return Swatch(new_gradients, maxn=self.maxn)

    def maximize_contrast_optimization(self, background_color: Union[Color, str], level: str = 'AA',
                                     method: str = 'golden_section') -> 'Swatch':
        """Maximize contrast of all gradients using mathematical optimization.

        Parameters
        ----------
        background_color : Color or str
            The background color to maximize contrast against.
        level : str, default 'AA'
            The WCAG level to achieve ('AA' or 'AAA').
        method : str, default 'golden_section'
            The optimization method to use ('golden_section' or 'gradient_descent').

        Returns
        -------
        Swatch
            A new swatch with maximized contrast gradients.

        Examples
        --------

        Maximize contrast with optimization:

        .. testcode::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff6666', '#66ff66'], name='Light')]
            swatch = Swatch(gradients)
            optimized = swatch.maximize_contrast_optimization('white')
            optimized

        .. html-output::

            from chromo_map import Swatch, Gradient
            gradients = [Gradient(['#ff6666', '#66ff66'], name='Light')]
            swatch = Swatch(gradients)
            optimized = swatch.maximize_contrast_optimization('white')
            print(optimized._repr_html_())

        """
        new_gradients = [gradient.maximize_contrast_optimization(background_color, level, method) for gradient in self.gradients]
        return Swatch(new_gradients, maxn=self.maxn)

    def _repr_html_(self) -> str:
        """Return HTML representation for Jupyter notebook display."""
        result = self.to_grid()
        if hasattr(result, 'data'):
            return result.data
        return str(result)


def _gud_name(name):
    return not (name[0] == "_" or name[-2:] == "_r")


class ColorMapDict(AttrDict):
    """AttrDict subclass that displays collections of gradients as a Swatch."""
    
    def _repr_html_(self) -> str:
        """Return HTML representation for Jupyter notebook display."""
        # Collect all gradient values from this dict
        gradients = []
        for value in self.values():
            if isinstance(value, Gradient):
                gradients.append(value)
            elif isinstance(value, ColorMapDict):
                # Recursively collect gradients from nested dicts
                gradients.extend(self._collect_gradients(value))
        
        if gradients:
            swatch = Swatch(gradients)
            return swatch._repr_html_()
        return f"<div>Empty ColorMapDict with {len(self)} categories</div>"
    
    def _collect_gradients(self, nested_dict):
        """Recursively collect all gradients from nested structure."""
        gradients = []
        for value in nested_dict.values():
            if isinstance(value, Gradient):
                gradients.append(value)
            elif isinstance(value, ColorMapDict):
                gradients.extend(self._collect_gradients(value))
        return gradients


def _dig_for_gradients(gradient_nest, prefix=tuple()):
    """Recursively dig through nested structures to find gradients."""
    for name, value in gradient_nest.items():
        if isinstance(value, dict):
            yield from _dig_for_gradients(value, (*prefix, name))
        else:
            yield ((*prefix, name), value)


def _build_matplotlib_catalog() -> Dict[str, Dict[str, str]]:
    """Build catalog of matplotlib colormaps organized by category."""
    mpl_data = json.loads(
        files("chromo_map.data").joinpath("mpl_cat_names.json").read_text()
    )
    
    # Map matplotlib categories to standardized types
    category_mapping = {
        'Perceptually Uniform Sequential': 'sequential',
        'Sequential': 'sequential', 
        'Sequential (2)': 'sequential',
        'Diverging': 'diverging',
        'Cyclic': 'cyclic',
        'Qualitative': 'qualitative',
        'Miscellaneous': 'miscellaneous'
    }
    
    # Build the catalog
    catalog = {}
    for category, names in mpl_data:
        mapped_category = category_mapping.get(category, 'miscellaneous')
        catalog[mapped_category] = catalog.get(mapped_category, {})
        for name in names:
            catalog[mapped_category][name] = name
    
    return catalog


def _build_plotly_catalog() -> Dict[str, Dict[str, Dict[str, List[str]]]]:
    """Build catalog of plotly color scales organized by category."""
    catalog: Dict[str, Dict[str, Dict[str, List[str]]]] = {}
    
    # Get all color scales from plotly using find_instances
    plotly_cmaps = find_instances(
        cls=list,
        module=plotly_colors,
        tracker_type=AttrDict,
        filter_func=lambda name, _: _gud_name(name),
    )
    
    # Convert to flat structure
    plotly_collections = dict(_dig_for_gradients(plotly_cmaps))
    
    # Define plotly types
    plotly_types = {'sequential', 'diverging', 'qualitative', 'cyclical'}
    
    for key, value in plotly_collections.items():
        original_key = key
        
        # Handle different key structures
        if len(key) == 1:
            key = ('miscellaneous', 'plotly', key[0])
        elif len(key) >= 2:
            if key[0] not in plotly_types:
                key = ('miscellaneous', key[0], key[1] if len(key) > 1 else key[0])
            else:
                key = (key[0], 'plotly', key[1] if len(key) > 1 else key[0])
        
        typ, palette_name, gradient_name = key[:3]
        
        try:
            # Ensure the structure exists
            if typ not in catalog:
                catalog[typ] = {}
            if palette_name not in catalog[typ]:
                catalog[typ][palette_name] = {}
            
            # Store the color list directly
            catalog[typ][palette_name][gradient_name] = value
        except Exception as e:
            print(f"Error processing plotly colormap {original_key}: {e}")
    
    return catalog


def _build_palettable_catalog() -> Dict[str, Dict[str, Dict[str, Palette]]]:
    """Build catalog of palettable palettes organized by module and category."""
    catalog: Dict[str, Dict[str, Dict[str, Palette]]] = {}
    
    # Get all palettes using find_instances
    palettes = find_instances(
        cls=Palette,
        module=palettable,
        tracker_type=AttrDict,
        filter_func=lambda name, _: _gud_name(name),
    )
    
    # Convert to nested structure and process
    palettes_sift = {}
    for key, value in _dig_for_gradients(palettes):
        # Handle different key structures
        if len(key) == 2:
            key = (key[0], 'special', key[1])
        
        if len(key) >= 3:
            palette_name, palette_type, gradient_name = key[:3]
            
            # Extract gradient name without number suffix
            if '_' in gradient_name:
                gradient_name, number_suffix = gradient_name.rsplit('_', maxsplit=1)
            
            # Build nested structure
            if palette_type not in palettes_sift:
                palettes_sift[palette_type] = {}
            if palette_name not in palettes_sift[palette_type]:
                palettes_sift[palette_type][palette_name] = {}
            if gradient_name.lower() not in palettes_sift[palette_type][palette_name]:
                palettes_sift[palette_type][palette_name][gradient_name.lower()] = {}
            
            palettes_sift[palette_type][palette_name][gradient_name.lower()][key[-1]] = value
    
    # Select best representative for each gradient
    for palette_type, level1 in palettes_sift.items():
        for palette_name, level2 in level1.items():
            for gradient_name, gradients in level2.items():
                if palette_type not in catalog:
                    catalog[palette_type] = {}
                if palette_name not in catalog[palette_type]:
                    catalog[palette_type][palette_name] = {}
                
                # Select the gradient with the most colors
                best_gradient = max(gradients.values(), key=lambda x: len(x.mpl_colors))
                catalog[palette_type][palette_name][gradient_name] = best_gradient
    
    return catalog


def _calculate_quality_score(colors: List[str], source: str) -> float:
    """Calculate a quality score for a colormap based on various factors."""
    score = 0.0
    
    # Length bonus (more colors generally better)
    score += min(len(colors) / 10.0, 1.0) * 20
    
    # Source preference (matplotlib > plotly > palettable for consistency)
    source_scores = {'matplotlib': 30, 'plotly': 25, 'palettable': 20}
    score += source_scores.get(source, 10)
    
    # Name quality (shorter, cleaner names preferred)
    name_penalty = len(colors[0]) / 50.0 if colors else 0
    score -= name_penalty * 5
    
    # Smoothness (for gradients - check if colors form a smooth progression)
    if len(colors) >= 3:
        try:
            # Simple heuristic: check if colors progress smoothly
            gradient = Gradient(colors[:min(len(colors), 8)])
            score += 10  # Bonus for being able to create gradient
        except:
            pass  # No penalty if gradient creation fails
    
    return score


def _find_best_representative(
    candidates: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """Find the best representative from a list of candidates."""
    if not candidates:
        return {}
    
    # Calculate scores for all candidates
    scored = []
    for candidate in candidates:
        score = _calculate_quality_score(
            candidate.get('colors', []), 
            candidate.get('source', '')
        )
        scored.append((score, candidate))
    
    # Return the highest scoring candidate
    return max(scored, key=lambda x: x[0])[1]


def _build_unified_catalog() -> AttrDict:
    """Build a unified catalog with multiple organization structures."""
    cmaps = AttrDict()
    
    # Build individual catalogs
    mpl_catalog = _build_matplotlib_catalog()
    plotly_catalog = _build_plotly_catalog()
    palettable_catalog = _build_palettable_catalog()
    
    # === MATPLOTLIB STRUCTURES ===
    # 1. matplotlib_by_type_by_palette_name
    cmaps.matplotlib_by_type_by_palette_name = ColorMapDict()
    for typ, colormaps in mpl_catalog.items():
        cmaps.matplotlib_by_type_by_palette_name[typ] = ColorMapDict()
        for name, cmap_name in colormaps.items():
            cmaps.matplotlib_by_type_by_palette_name[typ][name] = Gradient(cmap_name, name=name)
    
    # 2. matplotlib_by_palette_name (flat by name)
    cmaps.matplotlib_by_palette_name = ColorMapDict()
    for typ, colormaps in mpl_catalog.items():
        for name, cmap_name in colormaps.items():
            cmaps.matplotlib_by_palette_name[name] = Gradient(cmap_name, name=name)
    
    # 3. matplotlib_by_type (grouped by type)
    cmaps.matplotlib_by_type = ColorMapDict()
    for typ, colormaps in mpl_catalog.items():
        gradients = [Gradient(cmap_name, name=name) for name, cmap_name in colormaps.items()]
        cmaps.matplotlib_by_type[typ] = ColorMapDict({name: grad for name, grad in zip(colormaps.keys(), gradients)})
    
    # === PLOTLY STRUCTURES ===
    # 1. plotly_by_type_by_palette_name
    cmaps.plotly_by_type_by_palette_name = ColorMapDict()
    for typ, palettes in plotly_catalog.items():
        cmaps.plotly_by_type_by_palette_name[typ] = ColorMapDict()
        for palette_name, gradients in palettes.items():
            cmaps.plotly_by_type_by_palette_name[typ][palette_name] = ColorMapDict()
            for gradient_name, colors in gradients.items():
                try:
                    cmaps.plotly_by_type_by_palette_name[typ][palette_name][gradient_name] = Gradient(colors, name=gradient_name)
                except:
                    continue
    
    # 2. plotly_by_palette_name (flat by name)
    cmaps.plotly_by_palette_name = ColorMapDict()
    for typ, palettes in plotly_catalog.items():
        for palette_name, gradients in palettes.items():
            for gradient_name, colors in gradients.items():
                try:
                    cmaps.plotly_by_palette_name[gradient_name] = Gradient(colors, name=gradient_name)
                except:
                    continue
    
    # 3. plotly_by_type (grouped by type)
    cmaps.plotly_by_type = ColorMapDict()
    for typ, palettes in plotly_catalog.items():
        cmaps.plotly_by_type[typ] = ColorMapDict()
        for palette_name, gradients in palettes.items():
            for gradient_name, colors in gradients.items():
                try:
                    cmaps.plotly_by_type[typ][gradient_name] = Gradient(colors, name=gradient_name)
                except:
                    continue
    
    # === PALETTABLE STRUCTURES ===
    # 1. palettable_by_type_by_palette_name
    cmaps.palettable_by_type_by_palette_name = ColorMapDict()
    for typ, palettes in palettable_catalog.items():
        cmaps.palettable_by_type_by_palette_name[typ] = ColorMapDict()
        for palette_name, gradients in palettes.items():
            cmaps.palettable_by_type_by_palette_name[typ][palette_name] = ColorMapDict()
            for gradient_name, palette in gradients.items():
                try:
                    cmaps.palettable_by_type_by_palette_name[typ][palette_name][gradient_name] = Gradient(palette.mpl_colors, name=gradient_name)
                except:
                    continue
    
    # 2. palettable_by_palette_name (flat by name)
    cmaps.palettable_by_palette_name = ColorMapDict()
    for typ, palettes in palettable_catalog.items():
        for palette_name, gradients in palettes.items():
            for gradient_name, palette in gradients.items():
                try:
                    cmaps.palettable_by_palette_name[gradient_name] = Gradient(palette.mpl_colors, name=gradient_name)
                except:
                    continue
    
    # 3. palettable_by_type (grouped by type)
    cmaps.palettable_by_type = ColorMapDict()
    for typ, palettes in palettable_catalog.items():
        cmaps.palettable_by_type[typ] = ColorMapDict()
        for palette_name, gradients in palettes.items():
            for gradient_name, palette in gradients.items():
                try:
                    cmaps.palettable_by_type[typ][gradient_name] = Gradient(palette.mpl_colors, name=gradient_name)
                except:
                    continue
    
    # === LEGACY STRUCTURES (for backward compatibility) ===
    cmaps.matplotlib = cmaps.matplotlib_by_type_by_palette_name
    cmaps.plotly = cmaps.plotly_by_type_by_palette_name
    cmaps.palettable = cmaps.palettable_by_type_by_palette_name
    
    # === UNIFIED FLAT ACCESS ===
    # Build unified flat access with best representatives
    all_colormaps: Dict[str, List[Dict[str, Any]]] = {}
    
    # Collect all colormaps with metadata
    for typ, colormaps in mpl_catalog.items():
        for name, cmap_name in colormaps.items():
            key = name.lower()
            if key not in all_colormaps:
                all_colormaps[key] = []
            all_colormaps[key].append({
                'name': name,
                'source': 'matplotlib',
                'colors': cmap_name,
                'category': typ,
                'gradient': Gradient(cmap_name, name=name)
            })
    
    for typ, palettes in plotly_catalog.items():
        for palette_name, gradients in palettes.items():
            for gradient_name, colors in gradients.items():
                key = gradient_name.lower()
                if key not in all_colormaps:
                    all_colormaps[key] = []
                try:
                    all_colormaps[key].append({
                        'name': gradient_name,
                        'source': 'plotly',
                        'colors': colors,
                        'category': typ,
                        'gradient': Gradient(colors, name=gradient_name)
                    })
                except:
                    continue
    
    for typ, palettes in palettable_catalog.items():
        for palette_name, gradients in palettes.items():
            for gradient_name, palette in gradients.items():
                key = gradient_name.lower()
                if key not in all_colormaps:
                    all_colormaps[key] = []
                try:
                    all_colormaps[key].append({
                        'name': gradient_name,
                        'source': 'palettable',
                        'colors': palette.mpl_colors,
                        'category': f"{typ}.{palette_name}",
                        'gradient': Gradient(palette.mpl_colors, name=gradient_name)
                    })
                except:
                    continue
    
    # Create flat access with best representatives
    cmaps.all = ColorMapDict()
    for key, candidates in all_colormaps.items():
        best = _find_best_representative(candidates)
        if best:
            cmaps.all[key] = best['gradient']
    
    return cmaps


def contrast_ratio(color1: Union[Color, str], color2: Union[Color, str]) -> float:
    """Calculate the contrast ratio between two colors.

    Uses the WCAG 2.1 formula for contrast ratio.

    Parameters
    ----------
    color1 : Color or str
        The first color.
    color2 : Color or str
        The second color.

    Returns
    -------
    float
        The contrast ratio (1:1 to 21:1).

    Examples
    --------

    Calculate contrast ratio between black and white:

    .. testcode::

        from chromo_map import contrast_ratio
        ratio = contrast_ratio('black', 'white')
        print(f"Contrast ratio: {ratio:.1f}:1")

    .. testoutput::

        Contrast ratio: 21.0:1

    """
    c1 = Color(color1) if not isinstance(color1, Color) else color1
    c2 = Color(color2) if not isinstance(color2, Color) else color2
    return c1.contrast_ratio(c2)


def is_accessible(color1: Union[Color, str], color2: Union[Color, str], level: str = 'AA') -> bool:
    """Check if two colors have sufficient contrast for accessibility.

    Parameters
    ----------
    color1 : Color or str
        The first color (typically text).
    color2 : Color or str
        The second color (typically background).
    level : str, default 'AA'
        The WCAG level to check against ('AA' or 'AAA').

    Returns
    -------
    bool
        True if the contrast ratio meets the specified level.

    Examples
    --------

    Check if black text on white background is accessible:

    .. testcode::

        from chromo_map import is_accessible
        is_accessible('black', 'white')

    .. testoutput::

        True

    """
    c1 = Color(color1) if not isinstance(color1, Color) else color1
    c2 = Color(color2) if not isinstance(color2, Color) else color2
    return c1.is_accessible(c2, level)


def find_accessible_color(base_color: Union[Color, str], target_color: Union[Color, str], 
                         level: str = 'AA', adjust_lightness: bool = True) -> Color:
    """Find an accessible version of a color by adjusting it.

    Parameters
    ----------
    base_color : Color or str
        The color to adjust.
    target_color : Color or str
        The color to ensure accessibility against.
    level : str, default 'AA'
        The WCAG level to achieve ('AA' or 'AAA').
    adjust_lightness : bool, default True
        Whether to adjust lightness (True) or brightness/value (False).

    Returns
    -------
    Color
        An accessible version of the base color.

    Examples
    --------

    Find an accessible version of gray against white:

    .. testcode::

        from chromo_map import find_accessible_color
        accessible = find_accessible_color('#888888', 'white')
        print(f"Accessible color: {accessible.hex}")

    .. testoutput::

        Accessible color: #595959

    """
    base = Color(base_color) if not isinstance(base_color, Color) else base_color
    target = Color(target_color) if not isinstance(target_color, Color) else target_color
    
    required_ratio = 7.0 if level == 'AAA' else 4.5
    current_ratio = base.contrast_ratio(target)
    
    if current_ratio >= required_ratio:
        return base
    
    # Determine if we need to make the color lighter or darker
    base_luminance = base.luminance
    target_luminance = target.luminance
    
    if base_luminance > target_luminance:
        # Make base color lighter
        factor = 1.1
        max_factor = 2.0
    else:
        # Make base color darker
        factor = 0.9
        max_factor = 0.1
    
    current_color = base
    attempts = 0
    max_attempts = 50
    
    while current_color.contrast_ratio(target) < required_ratio and attempts < max_attempts:
        if adjust_lightness:
            current_color = current_color.adjust_lightness(factor)
        else:
            current_color = current_color.adjust_brightness(factor)
        
        attempts += 1
        
        # Prevent infinite loops
        if factor > 1 and factor >= max_factor:
            break
        elif factor < 1 and factor <= max_factor:
            break
    
    return current_color


def find_maximal_contrast_iterative(base_color: Union[Color, str], target_color: Union[Color, str], 
                                   level: str = 'AA', adjust_lightness: bool = True, 
                                   step_size: float = 0.1, max_attempts: int = 50) -> Color:
    """Find maximal contrast using simple iterative approach.
    
    This approach incrementally adjusts the color until it meets the contrast requirement.
    Simple but may not find the optimal solution.
    
    Parameters
    ----------
    base_color : Color or str
        The color to adjust.
    target_color : Color or str
        The color to ensure accessibility against.
    level : str, default 'AA'
        The WCAG level to achieve ('AA' or 'AAA').
    adjust_lightness : bool, default True
        Whether to adjust lightness (True) or brightness/value (False).
    step_size : float, default 0.1
        The step size for adjustments.
    max_attempts : int, default 50
        Maximum number of adjustment attempts.
    
    Returns
    -------
    Color
        The adjusted color with maximal contrast found.
    
    Examples
    --------
    
    Find maximal contrast iteratively:
    
    .. testcode::
    
        from chromo_map import find_maximal_contrast_iterative
        result = find_maximal_contrast_iterative('#888888', 'white')
        print(f"Iterative result: {result.hex}")
    
    .. testoutput::
    
        Iterative result: #595959
    
    """
    base = Color(base_color) if not isinstance(base_color, Color) else base_color
    target = Color(target_color) if not isinstance(target_color, Color) else target_color
    
    required_ratio = 7.0 if level == 'AAA' else 4.5
    
    # Determine direction based on luminance
    base_luminance = base.luminance
    target_luminance = target.luminance
    
    current_color = base
    best_color = base
    best_contrast = base.contrast_ratio(target)
    
    # Try both directions to find maximum contrast
    for direction in [1, -1]:
        temp_color = base
        attempts = 0
        
        while attempts < max_attempts:
            try:
                if adjust_lightness:
                    if direction == 1:
                        next_color = temp_color.adjust_lightness(1 + step_size)
                    else:
                        next_color = temp_color.adjust_lightness(1 - step_size)
                else:
                    if direction == 1:
                        next_color = temp_color.adjust_brightness(1 + step_size)
                    else:
                        next_color = temp_color.adjust_brightness(1 - step_size)
                
                next_contrast = next_color.contrast_ratio(target)
                
                if next_contrast > best_contrast:
                    best_contrast = next_contrast
                    best_color = next_color
                    temp_color = next_color
                else:
                    break  # No improvement, stop in this direction
                
                attempts += 1
            except (ZeroDivisionError, ValueError):
                break  # Stop if adjustment fails
    
    return best_color


def find_maximal_contrast_binary_search(base_color: Union[Color, str], target_color: Union[Color, str], 
                                       level: str = 'AA', adjust_lightness: bool = True, 
                                       precision: float = 0.001) -> Color:
    """Find maximal contrast using binary search approach.
    
    This approach uses binary search to efficiently find the optimal adjustment factor
    that maximizes contrast while meeting accessibility requirements.
    
    Parameters
    ----------
    base_color : Color or str
        The color to adjust.
    target_color : Color or str
        The color to ensure accessibility against.
    level : str, default 'AA'
        The WCAG level to achieve ('AA' or 'AAA').
    adjust_lightness : bool, default True
        Whether to adjust lightness (True) or brightness/value (False).
    precision : float, default 0.001
        The precision for binary search convergence.
    
    Returns
    -------
    Color
        The adjusted color with maximal contrast found.
    
    Examples
    --------
    
    Find maximal contrast using binary search:
    
    .. testcode::
    
        from chromo_map import find_maximal_contrast_binary_search
        result = find_maximal_contrast_binary_search('#888888', 'white')
        print(f"Binary search result: {result.hex}")
    
    .. testoutput::
    
        Binary search result: #595959
    
    """
    base = Color(base_color) if not isinstance(base_color, Color) else base_color
    target = Color(target_color) if not isinstance(target_color, Color) else target_color
    
    required_ratio = 7.0 if level == 'AAA' else 4.5
    
    # Determine search direction
    base_luminance = base.luminance
    target_luminance = target.luminance
    
    best_color = base
    best_contrast = base.contrast_ratio(target)
    
    # Search in both directions to find maximum
    for search_direction in ['lighter', 'darker']:
        if search_direction == 'lighter':
            low, high = 1.0, 3.0  # Factor range for making lighter
        else:
            low, high = 0.1, 1.0  # Factor range for making darker
        
        while (high - low) > precision:
            mid = (low + high) / 2
            
            try:
                if adjust_lightness:
                    test_color = base.adjust_lightness(mid)
                else:
                    test_color = base.adjust_brightness(mid)
                
                test_contrast = test_color.contrast_ratio(target)
                
                if test_contrast > best_contrast:
                    best_contrast = test_contrast
                    best_color = test_color
                
                # Binary search logic - try to find the extreme that gives max contrast
                if search_direction == 'lighter':
                    # For lighter colors, higher factors usually give more contrast
                    if test_contrast >= required_ratio:
                        low = mid  # Can go lighter
                    else:
                        high = mid  # Too light, go back
                else:
                    # For darker colors, lower factors usually give more contrast
                    if test_contrast >= required_ratio:
                        high = mid  # Can go darker
                    else:
                        low = mid  # Too dark, go back
            except (ZeroDivisionError, ValueError):
                break  # Exit if color adjustment fails
    
    return best_color


def find_maximal_contrast_optimization(base_color: Union[Color, str], target_color: Union[Color, str], 
                                     level: str = 'AA', method: str = 'golden_section') -> Color:
    """Find maximal contrast using mathematical optimization.
    
    This approach uses mathematical optimization techniques to find the adjustment
    that maximizes contrast ratio while meeting accessibility requirements.
    
    Parameters
    ----------
    base_color : Color or str
        The color to adjust.
    target_color : Color or str
        The color to ensure accessibility against.
    level : str, default 'AA'
        The WCAG level to achieve ('AA' or 'AAA').
    method : str, default 'golden_section'
        The optimization method to use ('golden_section' or 'gradient_descent').
    
    Returns
    -------
    Color
        The adjusted color with maximal contrast found.
    
    Examples
    --------
    
    Find maximal contrast using optimization:
    
    .. testcode::
    
        from chromo_map import find_maximal_contrast_optimization
        result = find_maximal_contrast_optimization('#888888', 'white')
        print(f"Optimization result: {result.hex}")
    
    .. testoutput::
    
        Optimization result: #595959
    
    """
    base = Color(base_color) if not isinstance(base_color, Color) else base_color
    target = Color(target_color) if not isinstance(target_color, Color) else target_color
    
    required_ratio = 7.0 if level == 'AAA' else 4.5
    
    def objective_function(factor: float) -> float:
        """Objective function to maximize contrast ratio."""
        try:
            # Try both lightness and brightness adjustments
            lightness_color = base.adjust_lightness(factor)
            brightness_color = base.adjust_brightness(factor)
            
            lightness_contrast = lightness_color.contrast_ratio(target)
            brightness_contrast = brightness_color.contrast_ratio(target)
            
            # Return the maximum contrast achievable
            return max(lightness_contrast, brightness_contrast)
        except (ZeroDivisionError, ValueError):
            return 0.0  # Return minimal contrast if adjustment fails
    
    if method == 'golden_section':
        # Golden section search for maximum
        phi = (1 + 5**0.5) / 2  # Golden ratio
        resphi = 2 - phi
        
        # Search bounds
        a, b = 0.1, 3.0
        tol = 1e-5
        
        # Initial points
        x1 = a + resphi * (b - a)
        x2 = a + (1 - resphi) * (b - a)
        f1 = objective_function(x1)
        f2 = objective_function(x2)
        
        best_factor = x1 if f1 > f2 else x2
        best_contrast = max(f1, f2)
        
        while abs(b - a) > tol:
            if f1 > f2:
                b = x2
                x2 = x1
                f2 = f1
                x1 = a + resphi * (b - a)
                f1 = objective_function(x1)
            else:
                a = x1
                x1 = x2
                f1 = f2
                x2 = a + (1 - resphi) * (b - a)
                f2 = objective_function(x2)
            
            current_best = x1 if f1 > f2 else x2
            current_contrast = max(f1, f2)
            
            if current_contrast > best_contrast:
                best_contrast = current_contrast
                best_factor = current_best
        
        # Determine which adjustment method gives better contrast
        lightness_color = base.adjust_lightness(best_factor)
        brightness_color = base.adjust_brightness(best_factor)
        
        lightness_contrast = lightness_color.contrast_ratio(target)
        brightness_contrast = brightness_color.contrast_ratio(target)
        
        return lightness_color if lightness_contrast > brightness_contrast else brightness_color
    
    elif method == 'gradient_descent':
        # Simple gradient descent
        factor = 1.0
        learning_rate = 0.1
        max_iterations = 100
        
        best_factor = factor
        best_contrast = objective_function(factor)
        
        for _ in range(max_iterations):
            # Numerical gradient estimation
            epsilon = 1e-6
            gradient = (objective_function(factor + epsilon) - objective_function(factor - epsilon)) / (2 * epsilon)
            
            # Update factor in direction of gradient (maximize)
            new_factor = factor + learning_rate * gradient
            new_contrast = objective_function(new_factor)
            
            if new_contrast > best_contrast:
                best_contrast = new_contrast
                best_factor = new_factor
                factor = new_factor
            else:
                learning_rate *= 0.9  # Reduce learning rate
                
            # Early stopping if improvement is minimal
            if abs(new_contrast - best_contrast) < 1e-6:
                break
        
        # Determine which adjustment method gives better contrast
        lightness_color = base.adjust_lightness(best_factor)
        brightness_color = base.adjust_brightness(best_factor)
        
        lightness_contrast = lightness_color.contrast_ratio(target)
        brightness_contrast = brightness_color.contrast_ratio(target)
        
        return lightness_color if lightness_contrast > brightness_contrast else brightness_color
    
    else:
        raise ValueError(f"Unknown optimization method: {method}")


def generate_color_palette(base_color: Union[Color, str], scheme: str = 'complementary', 
                          count: int = 5) -> List[Color]:
    """Generate a color palette based on a base color and color scheme.

    Parameters
    ----------
    base_color : Color or str
        The base color for the palette.
    scheme : str, default 'complementary'
        The color scheme to use ('complementary', 'triadic', 'analogous', 'monochromatic', 'split_complementary').
    count : int, default 5
        The number of colors to generate.

    Returns
    -------
    List[Color]
        A list of colors forming the palette.

    Examples
    --------

    Generate a complementary palette:

    .. testcode::

        from chromo_map import generate_color_palette
        palette = generate_color_palette('red', 'complementary', 3)
        [color.hex for color in palette]

    .. testoutput::

        ['#ff0000', '#00ff00', '#0000ff']

    """
    base = Color(base_color) if not isinstance(base_color, Color) else base_color
    colors = [base]
    
    if scheme == 'complementary':
        if count > 1:
            colors.append(base.complementary())
        if count > 2:
            # Add variations of the base and complement
            for i in range(count - 2):
                factor = 0.7 + (i * 0.3 / (count - 3)) if count > 3 else 0.7
                colors.append(base.adjust_brightness(factor))
    
    elif scheme == 'triadic':
        triad1, triad2 = base.triadic()
        colors.extend([triad1, triad2])
        if count > 3:
            for i in range(count - 3):
                factor = 0.6 + (i * 0.4 / (count - 4)) if count > 4 else 0.6
                colors.append(base.adjust_saturation(factor))
    
    elif scheme == 'analogous':
        step = 30 if count <= 5 else 60 / (count - 1)
        for i in range(1, count):
            angle = step * i
            colors.append(base.adjust_hue(angle))
    
    elif scheme == 'monochromatic':
        for i in range(1, count):
            factor = 0.3 + (i * 0.7 / (count - 1))
            colors.append(base.adjust_brightness(factor))
    
    elif scheme == 'split_complementary':
        if count > 1:
            colors.append(base.adjust_hue(150))
        if count > 2:
            colors.append(base.adjust_hue(210))
        if count > 3:
            for i in range(count - 3):
                factor = 0.5 + (i * 0.5 / (count - 4)) if count > 4 else 0.5
                colors.append(base.adjust_saturation(factor))
    
    return colors[:count]


def analyze_color_harmony(colors: List[Union[Color, str]]) -> Dict[str, Any]:
    """Analyze the color harmony of a list of colors.

    Parameters
    ----------
    colors : List[Color or str]
        A list of colors to analyze.

    Returns
    -------
    Dict[str, Any]
        A dictionary containing harmony analysis results.

    Examples
    --------

    Analyze a list of colors:

    .. testcode::

        from chromo_map import analyze_color_harmony
        analysis = analyze_color_harmony(['red', 'green', 'blue'])
        print(f"Average contrast: {analysis['average_contrast']:.2f}")

    .. testoutput::

        Average contrast: 3.08

    """
    color_objects = [Color(c) if not isinstance(c, Color) else c for c in colors]
    
    if len(color_objects) < 2:
        return {
            'average_contrast': 0.0,
            'min_contrast': 0.0,
            'max_contrast': 0.0,
            'accessibility_score': 0.0,
            'hue_distribution': [],
            'saturation_range': (0.0, 0.0),
            'brightness_range': (0.0, 0.0)
        }
    
    # Calculate contrast ratios
    contrasts = []
    for i in range(len(color_objects)):
        for j in range(i + 1, len(color_objects)):
            contrasts.append(color_objects[i].contrast_ratio(color_objects[j]))
    
    # Calculate accessibility score (percentage of pairs that meet AA standard)
    accessible_pairs = sum(1 for c in contrasts if c >= 4.5)
    accessibility_score = accessible_pairs / len(contrasts) if contrasts else 0
    
    # Analyze hue distribution
    hues = [c.hsv[0] for c in color_objects]
    hue_distribution = sorted(hues)
    
    # Analyze saturation and brightness ranges
    saturations = [c.hsv[1] for c in color_objects]
    brightnesses = [c.hsv[2] for c in color_objects]
    
    return {
        'average_contrast': sum(contrasts) / len(contrasts) if contrasts else 0,
        'min_contrast': min(contrasts) if contrasts else 0,
        'max_contrast': max(contrasts) if contrasts else 0,
        'accessibility_score': accessibility_score,
        'hue_distribution': hue_distribution,
        'saturation_range': (min(saturations), max(saturations)),
        'brightness_range': (min(brightnesses), max(brightnesses))
    }


def get_gradient(name: str, case_sensitive: bool = False) -> Optional[Gradient]:
    """
    Search for a gradient by name with regex support across all sources.
    
    Searches in order: palettable, matplotlib, plotly.
    Prioritizes gradients with higher length (more colors).
    
    Parameters
    ----------
    name : str
        The name or regex pattern to search for
    case_sensitive : bool, default False
        Whether to perform case-sensitive search
        
    Returns
    -------
    Optional[Gradient]
        The best matching gradient, or None if no match found
        
    Examples
    --------
    
    Search for viridis:
    
    .. testcode::
    
        from chromo_map import get_gradient
        grad = get_gradient('viridis')
        print(grad.name if grad else 'Not found')
        
    .. testoutput::
    
        viridis
        
    Search with regex:
    
    .. testcode::
    
        from chromo_map import get_gradient
        grad = get_gradient('vir.*')
        print(grad.name if grad else 'Not found')
        
    .. testoutput::
    
        viridis
    """
    import re
    
    # Compile regex pattern
    flags = 0 if case_sensitive else re.IGNORECASE
    try:
        pattern = re.compile(name, flags)
    except re.error:
        # If regex compilation fails, treat as literal string
        pattern = re.compile(re.escape(name), flags)
    
    candidates = []
    
    # Search order: palettable, matplotlib, plotly
    search_order = [
        ('palettable', cmaps.palettable_by_palette_name),
        ('matplotlib', cmaps.matplotlib_by_palette_name), 
        ('plotly', cmaps.plotly_by_palette_name)
    ]
    
    for source, catalog in search_order:
        for gradient_name, gradient in catalog.items():
            if pattern.search(gradient_name):
                candidates.append({
                    'gradient': gradient,
                    'name': gradient_name,
                    'source': source,
                    'length': len(gradient.colors),
                    'source_priority': {'palettable': 3, 'matplotlib': 2, 'plotly': 1}[source]
                })
    
    if not candidates:
        return None
    
    # Sort by: source priority (desc), length (desc), name (asc)
    candidates.sort(key=lambda x: (x['source_priority'], x['length'], -len(x['name'])), reverse=True)
    
    return candidates[0]['gradient']


# Build the unified colormap catalog
cmaps = _build_unified_catalog()
